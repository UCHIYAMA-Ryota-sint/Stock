# 在庫管理システム開発のためのClineルール

## TypeScript関連のルール

1. **明示的な型定義**
   - 問題: パラメーターやオブジェクトの型が暗黙的に `any` になるエラーが発生
   - ルール: 常に明示的に型を定義する。特に関数のパラメーターやコールバック関数の引数には必ず型を指定する
   - 例: `(warehouse: any) => {...}` のように明示的に型を指定する

2. **型変換の注意点**
   - 問題: `setSelectedAllocationId`関数に文字列型の値を渡すと型エラーが発生
   - ルール: 状態更新関数に値を渡す際は、期待される型に合わせて適切に変換する
   - 例: 文字列から数値への変換は `parseInt(value)` または `Number(value)` を使用する

3. **オプショナルプロパティの扱い**
   - ルール: オプショナルなプロパティは型定義で明示的に `?` を使用する
   - 例: `interface FormData { required: string; optional?: string; }`

## APIエンドポイント設計のルール

1. **一貫したレスポンス形式**
   - ルール: すべてのAPIエンドポイントは一貫したレスポンス形式を使用する
   - 成功時: 適切なステータスコードと結果データを返す
   - エラー時: エラーメッセージを含むJSONオブジェクトと適切なステータスコードを返す
   - 例: `return NextResponse.json({ error: 'エラーメッセージ' }, { status: 400 })`

2. **バリデーションの徹底**
   - ルール: すべてのAPIエンドポイントで入力データのバリデーションを行う
   - 例: 必須パラメーターのチェック、数値の範囲チェック、日付の妥当性チェックなど

3. **トランザクション処理**
   - ルール: 複数のデータベース操作を伴う処理では、Prismaのトランザクションを使用する
   - 例: `await prisma.$transaction(async (tx) => { ... })`

## コンポーネント設計のルール

1. **Reactコンポーネントの分割**
   - ルール: 機能ごとに適切にコンポーネントを分割する
   - 例: 共通のレイアウト、ナビゲーション、フォームコンポーネントなど

2. **状態管理の原則**
   - ルール: コンポーネントの状態は最小限に保ち、必要な場合のみ親コンポーネントに持ち上げる
   - 例: フォームの状態はフォームコンポーネント内で管理し、送信時のみ親コンポーネントに通知する

3. **副作用の管理**
   - ルール: 副作用（APIリクエストなど）は `useEffect` フックで適切に管理する
   - 例: データ取得は `useEffect` 内で行い、依存配列を適切に設定する

## エラーハンドリングのルール

1. **try-catch構文の使用**
   - ルール: 非同期処理では必ず try-catch 構文を使用してエラーをキャッチする
   - 例:
     ```typescript
     try {
       const response = await fetch('/api/endpoint');
       // 処理
     } catch (err) {
       console.error('エラー:', err);
       setError('エラーメッセージ');
     }
     ```

2. **ユーザーへのエラー表示**
   - ルール: エラーが発生した場合は、ユーザーに分かりやすいメッセージを表示する
   - 例: エラー状態を管理する状態変数を用意し、エラー発生時に適切なUIを表示する

3. **ログ出力**
   - ルール: エラー発生時は必ずコンソールにログを出力する
   - 例: `console.error('エラーの内容:', error)`

## パフォーマンス最適化のルール

1. **不要な再レンダリングの防止**
   - ルール: メモ化を活用して不要な再レンダリングを防止する
   - 例: `useMemo`, `useCallback`, `React.memo` の適切な使用

2. **データ取得の最適化**
   - ルール: 必要なデータのみを取得し、キャッシュを活用する
   - 例: クエリパラメーターを使用して必要なデータのみをフィルタリングする

## コーディングスタイルのルール

1. **命名規則**
   - ルール: 変数名、関数名は意味が分かるように命名する
   - 例: `fetchItems`, `handleSubmit`, `isLoading` など

2. **コメント**
   - ルール: 複雑なロジックには適切にコメントを付ける
   - 例: 複雑な計算ロジックや非同期処理の流れなど

3. **コードの整理**
   - ルール: 関連する機能ごとにコードをグループ化する
   - 例: 状態変数、副作用、イベントハンドラーなど

## セキュリティのルール

1. **入力データのサニタイズ**
   - ルール: ユーザー入力データは必ずサニタイズする
   - 例: HTMLエスケープ、SQLインジェクション対策など

2. **認証・認可**
   - ルール: 保護されたリソースへのアクセスには適切な認証・認可を実装する
   - 例: ログイン状態の確認、権限チェックなど

## テストのルール

1. **単体テスト**
   - ルール: 重要なロジックには単体テストを作成する
   - 例: ユーティリティ関数、カスタムフックなど

2. **統合テスト**
   - ルール: APIエンドポイントには統合テストを作成する
   - 例: リクエスト・レスポンスの検証など

## デプロイのルール

1. **環境変数**
   - ルール: 環境依存の設定は環境変数で管理する
   - 例: データベース接続情報、APIキーなど

2. **ビルド最適化**
   - ルール: 本番環境用のビルドは最適化する
   - 例: コード分割、画像最適化など